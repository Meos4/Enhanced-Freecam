#include "libgte.hpp"

#include "Common/TemplateTypes.hpp"
#include "Common/Types.hpp"

#include <algorithm>
#include <array>

namespace PS1::libgte
{
	static constexpr std::array<s16, 192> normTable
	{
		0x1000, 0xFE0, 0xFC1, 0xFA3, 0xF85, 0xF68, 0xF4C, 0xF30, 0xF15,
		0xEFB, 0xEE1, 0xEC7, 0xEAE, 0xE96, 0xE7E, 0xE66, 0xE4F, 0xE38,
		0xE22, 0xE0C, 0xDF7, 0xDE2, 0xDCD, 0xDB9, 0xDA5, 0xD91, 0xD7E,
		0xD6B, 0xD58, 0xD45, 0xD33, 0xD21, 0xD10, 0xCFF, 0xCEE, 0xCDD,
		0xCCC, 0xCBC, 0xCAC, 0xC9C, 0xC8D, 0xC7D, 0xC6E, 0xC5F, 0xC51,
		0xC42, 0xC34, 0xC26, 0xC18, 0xC0A, 0xBFD, 0xBEF, 0xBE2, 0xBD5,
		0xBC8, 0xBBB, 0xBAF, 0xBA2, 0xB96, 0xB8A, 0xB7E, 0xB72, 0xB67,
		0xB5B, 0xB50, 0xB45, 0xB39, 0xB2E, 0xB24, 0xB19, 0xB0E, 0xB04,
		0xAF9, 0xAEF, 0xAE5, 0xADB, 0xAD1, 0xAC7, 0xABD, 0xAB4, 0xAAA,
		0xAA1, 0xA97, 0xA8E, 0xA85, 0xA7C, 0xA73, 0xA6A, 0xA61, 0xA59,
		0xA50, 0xA47, 0xA3F, 0xA37, 0xA2E, 0xA26, 0xA1E, 0xA16, 0xA0E,
		0xA06, 0x9FE, 0x9F6, 0x9EF, 0x9E7, 0x9E0, 0x9D8, 0x9D1, 0x9C9,
		0x9C2, 0x9BB, 0x9B4, 0x9AD, 0x9A5, 0x99E, 0x998, 0x991, 0x98A,
		0x983, 0x97C, 0x976, 0x96F, 0x969, 0x962, 0x95C, 0x955, 0x94F,
		0x949, 0x943, 0x93C, 0x936, 0x930, 0x92A, 0x924, 0x91E, 0x918,
		0x912, 0x90D, 0x907, 0x901, 0x8FB, 0x8F6, 0x8F0, 0x8EB, 0x8E5,
		0x8E0, 0x8DA, 0x8D5, 0x8CF, 0x8CA, 0x8C5, 0x8BF, 0x8BA, 0x8B5,
		0x8B0, 0x8AB, 0x8A6, 0x8A1, 0x89C, 0x897, 0x892, 0x88D, 0x888,
		0x883, 0x87E, 0x87A, 0x875, 0x870, 0x86B, 0x867, 0x862, 0x85E,
		0x859, 0x855, 0x850, 0x84C, 0x847, 0x843, 0x83E, 0x83A, 0x836,
		0x831, 0x82D, 0x829, 0x824, 0x820, 0x81C, 0x818, 0x814, 0x810,
		0x80C, 0x808, 0x804
	};

	static s8 lzcr(s32 lzcs)
	{
		static constexpr s8 bits{ sizeof(s32) * 8 };

		for (s8 i{ bits }; i != 0; --i)
		{
			if (((lzcs >> (i - 1)) & 1) != (lzcs >> (bits - 1)))
			{
				return bits - i;
			}
		}

		return bits;
	}

	template <Integral T>
	static void VectorNormalInternal(s32 x1, s32 y1, s32 z1, T* x2, T* y2, T* z2)
	{
		s32 t3{ x1 * x1 };
		s32 t4{ y1 * y1 };
		s32 t5{ z1 * z1 };

		if ((t3 + t4 + t5) > 0x7FFFFFFF)
		{
			*x2 = 0;
			*y2 = 0;
			*z2 = 0;
			return;
		}

		t3 += t4;
		s32 v0{ t3 + t5 };
		s32 v1{ libgte::lzcr(v0) };
		v1 &= -2;
		s32 t6{ 0x1F };
		t6 -= v1;
		t6 >>= 1;
		t3 = v1 + -0x18;
		if (t3 < 0)
		{
			t3 = 0x18;
			t3 -= v1;
			t4 = v0 >> t3;
		}
		else
		{
			t4 = v0 << t3;
		}
		t4 = std::clamp(t4 - 0x40, 0, 191);
		t5 = libgte::normTable[t4];
		*x2 = static_cast<T>((x1 * t5) >> t6);
		*y2 = static_cast<T>((y1 * t5) >> t6);
		*z2 = static_cast<T>((z1 * t5) >> t6);
	}

	void VectorNormal(VECTOR* v0, VECTOR* v1)
	{
		libgte::VectorNormalInternal(v0->vx, v0->vy, v0->vz, &v1->vx, &v1->vy, &v1->vz);
	}

	void VectorNormalSS(SVECTOR* v0, SVECTOR* v1)
	{
		libgte::VectorNormalInternal(v0->vx, v0->vy, v0->vz, &v1->vx, &v1->vy, &v1->vz);
	}

	VECTOR* ApplyMatrixLV(MATRIX* m, VECTOR* v0, VECTOR* v1)
	{
		const auto x{ v0->vx }, y{ v0->vy }, z{ v0->vz };
		v1->vx = (m->m[0][0] * x + m->m[0][1] * y + m->m[0][2] * z) >> 12;
		v1->vy = (m->m[1][0] * x + m->m[1][1] * y + m->m[1][2] * z) >> 12;
		v1->vz = (m->m[2][0] * x + m->m[2][1] * y + m->m[2][2] * z) >> 12;
		return v1;
	}

	MATRIX* MulMatrix0(MATRIX* m0, MATRIX* m1, MATRIX* m2)
	{
		const auto temp{ *m1 };

		for (s32 i{}; i < 3; ++i)
		{
			for (s32 j{}; j < 3; ++j)
			{
				m2->m[i][j] = 0;
			}
		}

		for (s32 i{}; i < 3; ++i)
		{
			for (s32 j{}; j < 3; ++j)
			{
				for (s32 k{}; k < 3; ++k)
				{
					m2->m[i][j] += (m0->m[i][k] * temp.m[k][j]) >> 12;
				}
			}
		}
		return m2;
	}
}